//
// Created by matthew on 4/20/25.
//

#include <iostream>
#include <string>
#include <vector>

#include "CLI/CLI.hpp"
#include "io/fileio.h"
#include "parser/parser.h"
#include "tokenizer/tokenizer.h"
#include "utils.h"


/**
 * Writes a tokenized representation of the given program lines to the given file handle
 * @param tokenFile The file handle to write to
 * @param programLines The lines of the program to write
 * @return The tokenized representation of the program lines as a vector of vectors
 */
std::vector<LineTokens> genTokenFile(std::ofstream& tokenFile,
                                     const std::vector<SourceFile>& programLines) {
    const std::vector<LineTokens> tokenizedLines = Tokenizer::tokenize(programLines);
    for (const LineTokens& tokenLine : tokenizedLines) {
        for (const Token& token : tokenLine.tokens) {
            constexpr unsigned char groupSep = 0x1d;
            std::string TokenCategory = std::to_string(static_cast<int>(token.category));
            if (static_cast<int>(token.category) < 10)
                TokenCategory.insert(0, "0");

            tokenFile << TokenCategory << token.value << groupSep;
        }
        tokenFile << std::endl;
    }

    return tokenizedLines;
}


/**
 * Writes a parser representation of the given tokenized lines to the given file handle
 * @param parserFile The file handle to write to
 * @param tokenizedLines The tokenized lines to parse
 * @return The memory layout generated by the parser
 */
MemLayout generateParserFile(std::ofstream& parserFile,
                             const std::vector<LineTokens>& tokenizedLines) {
    Parser parser{};
    MemLayout memLayout = parser.parse(tokenizedLines);

    for (const std::pair<const MemSection, std::vector<std::byte>>& pair : memLayout.data) {
        constexpr unsigned char groupSep = 0x1d;
        parserFile << groupSep << static_cast<unsigned char>(pair.first);
        for (const std::byte byte : pair.second)
            parserFile << static_cast<unsigned char>(byte);
    }

    return memLayout;
}


int main(const int argc, char* argv[]) {

    std::vector<std::string> inputFileNames;

    CLI::App app{"masm Intermediate Generator", "masm-fg"};
    app.add_option("input-file", inputFileNames, "Input file to load")
            ->required()
            ->allow_extra_args();

    try {
        app.parse(argc, argv);
    } catch (const CLI::ParseError& e) {
        return app.exit(e);
    }

    std::string projectName = getFileBasename(inputFileNames[0]);
    // Split off extension
    const size_t extPos = projectName.find_last_of('.');
    if (extPos != std::string::npos)
        projectName.erase(extPos); // Remove extension if it exists

    try {
        std::vector<SourceFile> programLines;
        programLines.reserve(inputFileNames.size()); // Preallocate memory for performance
        for (const std::string& fileName : inputFileNames)
            programLines.push_back({getFileBasename(fileName), readFile(fileName)});

        std::ofstream tokenFile;
        tokenFile.open(projectName + ".tkn");
        if (!tokenFile.is_open())
            throw std::runtime_error("Could not open file " + projectName + ".tkn");
        const std::vector<LineTokens> tokenizedLines = genTokenFile(tokenFile, programLines);

        std::ofstream parserFile;
        parserFile.open(projectName + ".pse");
        if (!parserFile.is_open())
            throw std::runtime_error("Could not open file " + projectName + ".pse");

        MemLayout memLayout = generateParserFile(parserFile, tokenizedLines);

        tokenFile.close();
        parserFile.close();
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }

    return 0;
}
